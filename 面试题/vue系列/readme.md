# 1. 说说你对vue的理解
 - 是什么
    是一个js框架，用于创建一个单页应用的web应用框架，主旨是简化web的开发，主要靠MVVM的驱动方式来实现试图的更新。

 - 特性
    1. MVVM (Model - View - ViewModel)
        1.1. Model--模型层：模板，业务逻辑的代码
        1.2. View--视图层：html页面
        1.3. ViewModel--视图模型层：用于将模型和视图进行连接通信
    2. 组件化
        2.1. 代码复用
        2.2. 降低整体的耦合度
    3. 指令
        3.1. 大大减少了手动操作DOM的代码量

# 2. 说说你对SPA的了解
SPA(Single Page Application) 即单页面应用，是一种前端开发技术，它与传统的页面应用开发方式不同，SPA应用将页面应用的逻辑和视图分离，当用户在SPA应用中进行操作时，仅对当前页面进行更新，而不会重新加载整个页面。

 - 是什么
    只有一个html页面，本质上只需要控制某一个代码片段被拿到html中生效而已。
 - 特性
    优点：页面在任何时候都不会重新加载，不会打断用户体验。

    缺点：
    不利于搜索引擎的抓取。  解决办法————使用服务端渲染SSR
    存在首屏加载时间过长的情况。解决办法————路由懒加载、SSR
    - SSR
        Server-Side Rendering（服务器渲染）：在vue项目中再启动一个node服务，负责直接响应首页的代码片段，项目其他的代码片段依然保持原有的加载方式，这样就能让用户第一时间看到首页。首页代码就是html代码，而其他页面代码是通过JSON生成的代码，所以便于检索关键字，利于SEO。

# 3. 说说你对双向绑定的理解
 - 是什么
    模板层的数据变更，会导致视图层的更新，视图层的更新也会导致模板层的数据改变

 - 原理(ViewModel的原理)
    1. 监听器：对所有的数据进行监听
    2. 解析器：对每个元素节点的指令进行解析

    双向绑定的理解
    1. vue的数据源会被劫持，在劫持的过程中为属性做依赖收集。vue中的观察者watcher负责更新视图，依赖收集到的是观察者watcher的实例对象。当属性值发生变更时会触发依赖，进而触发试图更新函数。
    2. 在数据劫持的同时，vue会编译模板，解析指令当视图层的数据发生变更时，编译器绑定的函数就会触发，进而获取到最新的数据值，再次通知watcher去触发依赖。

# 4. VUE2和VUE3的区别
 - 选项式API，组合式API
   - this 不需要了，拥抱函数式编程
   - 代码量大的话 data+methods+getters 相关的逻辑会变多，
   - 组合式的API 可以让 reactive/ref + computed/watch + provide/inject 以业务为单位在一起
 
 - 响应式原理
   vue2 difineProperty（一次性代理完） 
   vue3 reactive用的是proxy，有13种拦截方法 性能更好（懒代理）
        ref用的是面向对象的get set
        因为核心是 拦截 + track + trigger(set) + effect

 - v-if v-for 优先级
   - v-if 优先级高于 v-for
   举个例子，比如ul li 的渲染
   vue3修正了这个bug，如果v-if为false，v-for是没必要渲染的
 - weakmap的理解
   依赖关系的收集是靠全局的唯一的weakmap，以响应式对象为key，再是以响应式对象的属性为value，
   proxy可以一次性代理，属性值用track收集的函数数组（effect），全部执行
   为什么用weakmap ？ 组件有很多，响应式对象有很多，路由组件很多，当组件下线，路由切换了，有些响应式不用维护了，weakmap会在响应式对象被垃圾回收后自动删除相应的项目

 - 1. 速度更快：虚拟DOM实现的函数被重写，效率提升。编译模板的优化
   2. 体积减少：
      tree-shaking更彻底
   3. 更易维护
      函数式编程
   4. 更接近原生语法
   5. v3 template模板


# 5. 聊聊通信组件
   父子通信 子组件props接受
   子父通信 子组件 emit发布一个事件，父组件订阅该事件
   子父通信 子组件拿到父组件的数据并修改后emit出来，父组件靠v-model实现双向绑定
   子父通信 子组件defineExpose暴露出来值，父组件利用ref读取着整个子组件对象来获取值
   父子通信 父组件 provied 子组件 inject
   EventBus mitt插件
   vuex || pinia

* 插槽
   作用：
   使用场景：通常我们引入子组件后，放到页面去展示时，子组件的标签直接就缩写了，因为子组件开闭标签之间写东西是编译不出来的。所以slot插槽就是来解决这个问题的。举个例子，比如我们

9. 说说diff
同层级比较
深度优先
pathVnode步骤：

判断节点是不是文本，是的话直接更新文本
比较节点类型是否相同，不同则直接替换
比较子节点，不断生成补丁包
双端队列 提升比较的效率

# 6. v-for 和 v-if 共存吗
v2中，v-for优先级更高，会报警告，因为性能浪费
v3中，v-if优先级更高，没有用到for中的变量不会报错。
所以都不建议使用。

# 7. data 为什么要使用函数的形式
1.如果是对象的话，它里面的数据会被组件之间影响到。
 函数可以保证data是同一个对象，避免多次调用时，data被覆盖。

# 8. 修饰符

# 9. v-modle 的实现原理
   v-bind和v-on的语法糖，

# 10. 什么是虚拟DOM
   一个用js对象来描述的DOM结构
   当一次操作导致多处DOM需要修改，不使用虚拟DOM，浏览器需要重新一个一个构建这个DOM树，导致多次渲染，但是少量DOM更新diff算法同样存在性能开销
   跨平台

# 11. 为什么 外层要加一个div，VUE2中不加是会报错的
   <template>
      <div>
         <div> 1 </div>
         <div> 2 </div>
      </div>
   </template>
统一外层节点，简单方便的完成挂载。
缺点：为了挂载而添加一个新的外层节点，会增加额外的节点层级，造成污染。

VUE3中，不需要。
因为vue3中，引了Fragment概念，通过 document.createDocumentFragment() 创建一个空的文档片段,它是虚拟的，起到容器功能，会自动消失。

# 12. vue3的Proxy是怎么实现深层次的代理的

