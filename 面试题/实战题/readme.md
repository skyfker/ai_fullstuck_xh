1. 手动回收
    比如最早的c/c++就是手动回收
2. 自动回收 
    js

# 代际假说
    1. 大部分对象在内存中存在的时间是很短的 
    2. 不死的对象，会活的更久


# 分代收集


# v8
- 堆被分为新生代区和老生代区

- 新生代区：副垃圾回收器    老生代区：主垃圾回收器

- 垃圾回收器的工作流程
1. 标记空间中的活动对象和非活动对象
    活动对象：还在使用的对象
    非活动对象：要被回收的对象
2. 回收非活动对象的空间
3. 整理内存碎片

- 副垃圾回收器
将新生代区分成 对象空间 和 空闲空间，对象空间用于存放新进的小对象，当存满后执行回收处理，
再将存活的对象复制到空闲空间，此时就做好了内存整理，再反转对象空间 和 空闲空间，新对象空间继续接收对象
两次回收仍然存活的对象会晋升到老生代区

- 主垃圾回收器
因为存放的对象都比较大，所以不适合用副垃圾回收器相同的算法，只能采用标记清除法，递归一个对象
当对象中任何一个属性都没被使用，则作为垃圾回收掉，再整理空间

# 全停顿
- js运行在v8的主线程上，当垃圾回收机制生效时，js的执行要让出线程，那么js的执行就会暂停

- 采用增量标记法来进行垃圾回收过程中的标记过程，把它拆分成很多个小任务，和js执行来回切换执行