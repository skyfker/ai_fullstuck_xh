# 1. js数组上有哪些方法

1. 增加：push()、unshift()、concat()、splice()
2. 删除：pop()、shift()、splice()、slice()
3. 修改：reverse()、sort()
4. 查找：indexOf()、lastIndexOf()、include()、find()
5. 转换：join()
6. 迭代：forEach()、map()、filter()、some()、every()
7. Array.from()、Array.of()

# 2. 字符串上面有哪些方法
1. 增加：concat()
2. 删除：slice()、substr()、substring() // 效果与slice()一模一样
3. 修改：replace()、split()、toLowerCase()、toUpperCase()、trim()、trimLeft()、trimRight()、padStart()、padEnd()、
4. 查找：indexOf()、lastindexOf()、startWith()、endsWith()、includes()
5. 转换：split()

# 3. 谈谈js中的类型转换机制
- 显示转换：表示在代码中明确的使用转换函数将一种数据类型转换成另一种数据类型。
- 隐式转换：在某些运算或操作中，因为涉及到不同类型的数据，JS引擎会自动进行类型转换，从而实现运算或操作。

- 是什么：
js中有原始类型和引用类型：
原始类型：number string boolean undefined null symbol bigint
引用类型：[] {} function Date RegExp Set Map 

通常开发过程中，会用到一些显示类型转换的手段来完成逻辑开发。
Number...

在V8执行过程中还存在另一种类型转换 --- 隐式类型转换

通常发生在 比较运算符 和 算数运算符

==  !=  <  > if while 
+ - * / %

# 4. == 和 === 的区别
== 是比较运算符，比较的是值，不比较类型
=== 是比较运算符，比较的是值和类型

# 5. 深浅拷贝的区别？ 如何实现一个深拷贝
- 深浅拷贝通常只针对引用类型

- 浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针（引用地址）。修改原对象，会影响拷贝后的对象

 Object.assign()  slice()    concat()  [...arr]

- 深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象
 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function 循环引用

# 6. 说说你对闭包的理解
- 是什么
当一个函数中的内部函数被拿到函数外部调用，又因为在js中内层作用域总是能访问外层作用域的，那么内部函数存在对外部函数中变量的引用，这些变量的集合称之为闭包

- 使用场景：
 1. 创建私有变量  （全局变量不易维护）
 2. 延长变量的生命周期
 3. 实现柯里化（颗粒）

- 缺点：会造成内存泄漏

# 7. 什么是柯里化？
- 是什么
  将一个接受多个参数的函数转变成多个只接受一个参数的函数

# 8. 说说你对作用域的理解
- 是什么：
 变量和函数能够生效的区域，这个区域叫作用域

- 有哪些：
 1. 全局作用域
 2. 函数作用域
 3. 块级作用域

- 作用域链：作用域只能从内到外的访问，这种访问规则形成的链状关系我们称之为作用域链

- 词法作用域：指的是函数或变量定义的区域

# 9. 说说你对原型的理解
 - 是什么：
  1. 显示原型指的是函数身上自带的 prototype 属性, 通常可以将一些属性和方法添加在显示原型上，可供实例对象继承到

  2. 隐式原型 __proto__ 是对象这种结构上的一个属性，其中包含了创建该对象时，隐式继承到的属性

 - 原型链：创建一个实例对象时，实例对象的隐式原型===创建该对象的构造函数的显示原型，在js中对象的查找规则是先在对象中查找，找不到再去对象的隐式原型上查找，顺着隐式原型一层层往上找，直到找到null为止，这种查找规则我们就叫原型链


 - 可用来实现属性的继承

# 10. 说说js中的继承
 - 是什么：在js中继承指的是让一个子类可以访问父类的属性和方法

 - 继承有哪些方式：
  1. 原型链继承：（1.无法给父类灵活传参  2.多个实例对象共用了同一个原型对象存在属性相互影响）
  2. 构造函数继承：(1.只能继承到父类身上的属性，无法继承到父类原型上的属性)
  3. 组合继承（经典继承）：(1.存在多次父类函数的调用，多造成了性能开销)
  
  4. 原型式继承：（1.因为是浅拷贝，父类中的引用类型在子类之间共用了，会相互影响, 2.子类无法添加默认属性）
  5. 寄生式继承：（1. 同上）
  6. 寄生组合式继承

  7. class 继承

# 11. 说说js中的this
 - 是什么：this是函数在运行过程中自动生成的一个对象，用来代指作用域的指向 

 - 绑定规则：
  1. 默认绑定：当函数被独立调用时，函数的this指向window。(函数的词法作用域在哪里，this就指向哪个词法作用域)
  2. 隐式绑定：当函数被一个对象所调用时，函数的this指向该对象
  3. 隐式丢失：当函数调用前有多个对象，函数的this指向最近的对象
  4. 显示绑定：call, apply, bind
  5. new绑定：this指向实例对象

 - 箭头函数：箭头函数中的this是它外层非箭头函数的，指向也按照上述的绑定规则

# 12. new的实现原理
 - 构造函数有返回值，且为引用类型时会覆盖new当中的返回值

1. 创建this空对象
2. 执行构造函数中的逻辑
3. 让this的隐式原型===构造函数的显式原型
4. 返回this对象

# 13. call, apply, bind 原理


# 14. 说说JS中的事件模型？
1. DOM0级事件模型：onclick (无法控制事件在捕获冒泡哪个阶段执行)
2. DOM1级事件模型：addEventListener (可以控制事件在哪个阶段执行)
3. IE6以下：attachEvent (无法控制冒泡在哪个阶段执行)

# 15.  说说typeof 和 instanceof 的区别？
- typeof 
    能判断除了null之外的所有原始类型（typeof的底层逻辑是判断二进制码，通过前面是否有 000 ，null通体为0，所以被归为Object类型）

- instanceof
    能判断一个变量是否属于某种类型，是通过原型链来判断的

- 最优解：   object.prototype.tostring.call(x) 
            先看看object.prototype.toString()
    例如：object.prototype.toString({})  => '[object Object]'
         object.prototype.toString([])  => '[object Object]'

         object.prototype.toString.call([])  => ''
         效果相当于[].toString()，但不是一个tostring()方法

    object.prototype.tostring.call(x)，该方法会让变量 x 调用对象上的tostring()方法.
    而[].toString()  就是调用数组身上的toString()方法
    
# 16. 说说Ajax的原理？
- 是什么：
    asyncronous javascript and xml，是一种异步js和网页交互技术，可以实现不刷新网页就跟服务器进行数据交互，更新页面

- 实现过程：
    1. 创建一个XMLHttpRequest对象
    2. 调用实例对象中的open()方法
    3. 调用实例对象中的send()方法
    4. 监听onreadyStateChange事件，通过判断readyState的值来获取到最终数据

- readyState:
0: xhr 刚刚创建，请求还没发
1：open 准备完成
2：请求已经发送出去
3：接收到了服务端的响应体
4：数据解析完成

# 17. 怎么实现上拉加载，下拉刷新？
1. 监听 toutchstart   toutchmove   toutchend  事件，记录手指移动的距离，大于临界值时实现刷新操作，其中使用transform:translateY() 来添加各处动画

2. 根据手指滑动的方向和容器顶部或底部到屏幕的距离来确定此时该执行上拉加载更多 还是下拉刷新

# 18. 防抖节流
1. 防抖：如果一个函数持续地、频繁地触发，那么只在它结束后过一段时间才开始执行。换句话说，如果你持续触发事件，那么防抖函数将不会执行，只有当你停止触发事件后，它才会在指定的延迟时间后执行。这对于防止例如用户在输入框中连续输入时发送过多的Ajax请求等情况非常有用。
2. 节流：如果你持续触发事件，每隔一段时间，事件处理函数只执行一次。这有助于限制一些处理函数的执行频率，例如：滚动事件、窗口大小调整事件等。

# 19. 事件代理
- 事件委托：（多个子容器需要绑定相同事件）  将事件绑定到父容器上，通过事件对象的target属性判断事件触发的元素，然后执行相应的事件处理逻辑

# 20. 事件循环
- 是什么
  JS引擎在执行js代码时，会区分同步和异步代码，先执行同步代码在执行异步代码，异步代码中同样按照先执行同步代码再执行异步代码的顺序执行，以此往复。

- 异步
  1. 宏任务：script setTimeout()  setInterval()  setImmediate, I/O, UI-rendering  postMassage  

  2. 微任务：promise.then() nextTick(node)  MutationObserver

- Event-Loop（浏览器角度）
1. 执行同步代码（这也叫宏任务）
2. 执行微任务
3. 如果有需要，会渲染页面
4. 执行宏任务  （下一次event-loop的开始）

难点：
    1. 同步代码带来的微任务会在同步代码执行完后立即执行，而微任务带来的微任务会入微任务队列，按队列规则执行
    2. async/await async相当于promise， await 一脚把后续代码踹到微任务队列里,它自己也是微任务。但是浏览器给await开小灶提速，它会直接执行。
    

# 21. html5 文件读取：FileReader
- 为什么要用FileReader？
    1. 读取本地文件
    